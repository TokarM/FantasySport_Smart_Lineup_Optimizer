# -*- coding: utf-8 -*-
"""simulator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tUAZzg-iJPkveVXtG13s7KfFY68Q2iHQ
"""

import numpy
import pandas
from operator import add
from operator import truediv
from scipy.stats import poisson
from scipy.stats import nbinom


class Player_std():
    def __init__(self, position, name, salary, points, value, pred = 0, prob = 0):
        self.self = self
        self.position = position
        self.name = name
        self.salary = salary
        self.points = points
        self.value = value
        self.pred = pred
        self.prob = prob
        
    def __iter__(self):
        return iter(self.list)
    
    def __str__(self):
        return "{} {} {} {}".format(self.name,self.position,self.salary, self.points, self.pred, self.prob)

class Player():
    def __init__(self, position, name, salary, points, value, prob = 0, goal_chance = 0,
                 assist = 0, s = 0, sog = 0, interception = 0, cc = 0, cr = 0, fc = 0, fs = 0, tklw = 0, p = 0):
        self.self = self
        self.position = position
        self.name = name
        self.salary = salary
        self.points = points
        self.value = value
        self.prob = prob
        self.goal_chance = goal_chance
        self.assist = assist
        self.s = s
        self.sog = sog
        self.interception = interception
        self.cc = cc
        self.cr = cr
        self.fc = fc
        self.fs = fs
        self.tklw = tklw
        self.p = p
        
        
        
    def __iter__(self):
        return iter(self.list)
    
    def __str__(self):
        return "{} {} {} {} {} {} {}".format(self.name,self.position,self.salary, self.points, self.prob,
                self.goal_chance, self.assist, self.s, self.sog, self.interception, self.cc, self.cr, self.fc,
                self.fs, self.tklw, self.p)



def lineup_knapsack(players):
    cap = 100
    current_lineup_cap = 0
    limits = {
        'F/M':4,
        'D':2,
        'GK':1, 
        
        }
    
    counter = {
        'F/M':0,
        'D':0,
        'GK':0, 
        }
    
    players.sort(key=lambda x: x.value, reverse=True)
    lineup = []
    
    for player in players:
        nam = player.name
        pos = player.position
        sal = player.salary
        pts = poisson.rvs(player.points,1)
        if counter['F/M'] < limits['F/M'] and current_lineup_cap + sal <= cap and pos in ['FWD','MID']:
            lineup.append(player)
            counter['F/M'] = counter['F/M'] + 1
            current_lineup_cap += sal
            continue
        if counter['D'] < limits['D'] and current_lineup_cap + sal <= cap and pos in ['DEF']:
            lineup.append(player)
            counter['D'] = counter['D'] + 1
            current_lineup_cap += sal
            continue
        if counter['GK'] < limits['GK'] and current_lineup_cap + sal <= cap and pos in ['GK']:
            lineup.append(player)
            counter['GK'] = counter['GK'] + 1
            current_lineup_cap += sal
            continue
    #print(counter)   
    players.sort(key=lambda x: x.points, reverse=True)
    for player in players:
        nam = player.name
        pos = player.position
        sal = player.salary
        pts = poisson.rvs(player.points,1)
        if player not in lineup:
            pos_players = [ x for x in lineup if x.position == pos]
            pos_players.sort(key=lambda x: x.points)
            for pos_player in pos_players:
                if (current_lineup_cap + sal - pos_player.salary) <= cap and pts > pos_player.points:
                    lineup[lineup.index(pos_player)] = player
                    current_lineup_cap = current_lineup_cap + sal - pos_player.salary
                    break
    
    return lineup

# Read Players from csv file
    
def read_players(players_csv,probabilities, excepting = [], exc_team  = [], tour = 1):
    
    players = []
    for index, row in players_csv.iterrows():
        if (row['Team'] not in exc_team) and (row['Player'] not in excepting):
            
            p = 0
            for i in range(16, (16+tour)):
                #print(row['Name'])
                #print(row[i])
                if row[i] != '-':
                    if float(row[i]) >= row['FPPG']:
                        p += 1
                        
            name = row['Player']
            position = row['Position']
            salary = int(row['Salary'])
            points = float(row['FPPG'])
            value = points / salary
            probability = float(probabilities.loc[probabilities['Player']==name]['1'])
            pred = 0
            '''
            if prediction.shape[1] == 2:
                pred = float(prediction.loc[prediction['Player']==name][0])
            else:
                pred = float(prediction.loc[prediction['Player']==name]['1'])
            '''            
            player = Player_std(position, name, salary, points, value, pred, probability)
            players.append(player)        
    return players
    
# Modified Read CSV with Probabilities
    
def read_players_prob(players_csv, excepting = [], exc_team  = [], tour = 1):
    players = []
    for index, row in players_csv.iterrows():
        if (row['Team'] not in exc_team) and (row['Name'] not in excepting):
            p = 0
            for i in range(16, (16+tour)):
                #print(row['Name'])
                #print(row[i])
                if row[i] != '-':
                    if float(row[i]) >= row['FPPG']:
                        p += 1
    
            probability = p / tour
            name = row['Name']
            position = row['Position']
            salary = int(row['Salary'])
            points = float(row['FPPG'])
            value = points / salary  
            goal_chance = (float(row['Percentage']) / 100)
            assist = float(row['A'])
            s = float(row['S'])
            sog = float(row['SOG'])
            interception = float(row['INT'])
            cc = float(row['CC'])
            cr = float(row['CR'])
            fc = float(row['FC'])
            fs = float(row['FS'])
            tklw = float(row['TKLW'])
            p = float(row['P'])
            
            player = Player(position, name, salary, points, value, probability, goal_chance, assist, s,
                            sog, interception, cc, cr, fc, fs, tklw, p)
            players.append(player)        
    return players

# Prediction of one lineup with Poisson distributed points 
def prediction(players):
    
    lineup = lineup_knapsack(players)
    points = 0
    salary = 0
    p_list = []
    for player in lineup:
        points += player.points
        salary += player.salary
        p_list.append(player.name)
        #print(player)
    #print("\nPoints: {}".format(points))
    #print("Salary: {} \n".format(salary))

    return p_list

def count_points(a):
    
    pred_array = []
    indx = numpy.random.randint(low = 1, high = 10000, size = 1)
    # One Column Iteration Method
    
    p = numpy.zeros(len(players_csv))
    for lineup in a:
        for player in lineup:
            p[players_dict[player]] = 1
    points = numpy.matmul(p,players_matrix[:,indx])
    pred_array.append(points)
    return pred_array

# Test prediction lineups to actual results 
def test_lineups(lineups, results, week_str):
    # Iterating CSV file method
    team_points = []
    for lineup in lineups:
        points = 0
        counter = 0
        for index, row in results.iterrows():
            if row[week_str] != "-" and float(row[week_str]) > 0:
                if row['Player'] in lineup:
                    points = points + float(row[week_str])
                    counter += 1
            if counter > 5:
                break
        team_points.append([lineup, points])
        #print("\nPoints: {}".format(points))
    return team_points

#team = team.sort_values(by = [1], ascending = False)
 
# Creates lineups using knapsack algorithm           
def create_lineups(n,average):
    # Create lineups
    players = read_players()
    lineups = [['Initial']]
    
    for i in range(n):
        pred_players = prediction(players)
        flag = 0
        for lineup in lineups:
            if pred_players == lineup:
                
                i = i - 1
                flag = 1
                break
            
        if flag == 0: 
            lineups.append(pred_players)
        print(i)
    
       
    team_points = []
    counter = 0
    
    
    lineups.pop(0)
    # Test Lineups
    for lineup in lineups:
        
        points = 0
        for i in range(average):
            pred_array = count_points([lineup])
            points = points + pred_array[0]
        avg = points / average
        team_points.append([lineup, avg])
        counter += 1
        
    
    #Save teams to csv file
    team = pandas.DataFrame(team_points)
    team = team.sort_values(by = [1], ascending = False)
    return team

# Return players frequency in top lineups
def get_freq(play_dic, team):
    lines = team[0]
    #lines = lines.sample(frac = 1)
    lines.to_list()
    
    for key in play_dic:
        play_dic[key] = 0
    for lineup in lines:
        for pl in lineup:
            play_dic[pl] += 1
    
    return play_dic
 
def clean_lineup(play_dic, team, n):
    lines = team[0]
    #lines = lines.sample(frac = 1)
    lines.to_list()
    
    for key in play_dic:
        play_dic[key] = 0
        
    new_lineups = []
    for lineup in lines:
      counter = 0
      for pl in lineup:
          if play_dic[pl] > n:
              break
          else:
              counter += 1
      if counter == 7:
          for pl in lineup:  
              play_dic[pl] += 1
              lineup.sort()
          new_lineups.append(lineup)
    return new_lineups












